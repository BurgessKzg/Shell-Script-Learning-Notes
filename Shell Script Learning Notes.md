> &emsp;&emsp;GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。
> &emsp;&emsp;在Linux系统上，通常有好几种Linux shell可用。不同的shell有不同的特性，有些更利于创建脚本，有些则更利于管理进程。

> &emsp;&emsp;将多个shell命令放入文件中作为程序执行,这些文件被称作shell脚本。

[TOC]

# 1. shell编程脚本基础

## 1.1. 构建基本脚本

### 1.1.1. 使用多个命令

> &emsp;&emsp;shell可以将多个命令串起来一次执行完成,如果要多个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开(不超过最大命令行字符数255)。  

 - **eg:**    
    ```Shell
    $ date ; who
    ```

### 1.1.2. 创建shell脚本文件

> 1. 使用文本编辑器创建一个文件；
> 2. 必须在文件的第一行指定要使用的shell，格式： "`#!/bin/bash`"，"bash"可以换为别的shell；
> 3. 指定shell后就可以在每一行输入命令，然后加一个回车符；

- **注意**
    > - shell脚本中**井号**(#)用作**注释行**，shell**不处理**注释行，**第一行**是个例外，"#"后面的惊叹号告诉shell用哪个shell来运行脚本; 
    > - shell脚本中注释可用"#"添加，可以出现在**任意行**；
    > - shell脚本中可以根据需要使用**分号**将多个命令放在一行上；
    > - shell会按命令在文件中出现的**顺序**进行处理；
    > - shell会通过"**PATH**环境变量"来查找命令；
    > - 执行脚本需要让shell能找到脚本位置，方法：
    >   - 将shell脚本文件所处的目录添加到"PATH"环境变量中；
    >   - 在提示符中用绝对或相对文件路径来引用shell脚本文件；
    > - 如果umask使得创建的文件没有执行权限，使用"chmod"添加执行权限；

### 1.1.3. 显示消息

> 在"echo"命令后加上一个字符串，该命令能回显这个文本字符串；  

- **注意**
    > - 默认情况**不需要**使用引号将要显示的文本字符串划定；
    > - 要显示的字符串包括"'"(单引号)时，需要将字符串用"""(双引号)划定；
    > - 要显示的字符串包括"""(双引号)时，需要将字符串用"'"(单引号)划定；
    > - 以上两条不必用"""(双引号)或"'"单引号将整个字符串划定起来；
    > - "echo"回显的数据默认会换行，可以加"-n"选项去掉换行； 

### 1.1.4. 使用变量

> &emsp;&emsp;变量允许你临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。

#### 1.1.4.1. 环境变量

> &emsp;&emsp;shell维护一组环境变量，用来记录特定系统信息。比如系统名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。可以用"**set**"命令来显示一份**完整的**当前环境变量列表。

> - 脚本中，可以在环境变量名称前加上"$"(美元符)来使用环境变量(不需要加"-n"选项)，这个时候可以将环境变量放到引号里；
> - 脚本在引号中出现"$"(美元符)，它会以为你在引用一个变量；
> - 要在引号中显示"$"(美元符)，需要在它前面添加"\\"(反斜线)；

#### 1.1.4.2. 用户变量

> &emsp;&emsp;shell脚本允许在脚本中定义和使用自己的变量(用户变量)，定义变量允许临时存储数据并在整个脚本中使用。

> - 用户变量可是字母、数字或下划线任意组成的文本字符串；
> - 用户变量长度不超过20个字符；
> - 用户变量区分大小写；
> - 使用等号赋值给用户变量，在变量、等号和值之间**不能**出现空格；
> - shell脚本会自动决定变量值的数据类型；
> - 在脚本的整个生命周期里，shell脚本中定义的变量会一直保持它们的值，**但**在shell脚本结束时会被**删除**；
> - 与系统变量类似，用户变量可通过"$"(美元符)引用，变量每次被引用时，都会输出当前赋给它的值；
> - 引用一个**变量值时需要**使用美元符，而引用变量来对其进行赋值时则**不需要**使用美元符，没有美元符，shell会将变量名解释成普通的文本字符串；
> - 通过"${variable}"形式引用的变量,变量名两侧额外的花括号通常用来帮助识别美元符后的变量名；

#### 1.1.4.3. 命令替换

> &emsp;&emsp;shell脚本中，可以从命令输出中提取信息，并将其赋给变量。

- 两种方法可以将命令输出赋给变量：
    > - "\`"(反引号)，用一对反引号把整个命令行命令围起来；
    ```Shell
    var=`date`
    ```
    > - "$()"格式    
    ```shell
    var=$(date)
    ```
- **注意**
    > - 反引号字符**不是**用于字符串的那种普通单引号字符；
    > - 命令替换会创建一个子shell来运行对应的命令,由该子shell所执行命令是无法使用脚本中所创建的变量；
    > - 在命令行提示符下使用路径"./"运行命令也会创建子shell；要是运行命令的时候不加入路径就不会创建子shell，如果使用内建的shell命令，并不会涉及子shell；

- **eg:**
    > - 在脚本中通过命令替换获得当前日期并用它来生成唯一文件名
    ```shell
    #!/bin/bash
    # copy the /usr/bin directory listing to a log file
    # 格式化后的"date"命令的输出
    today=$(date +%y%m%d)
    ls /usr/bin -al > log.$today
    ```

### 1.1.5. 重定向输入和输出

> &emsp;&emsp;有时想要保存某个命令的输出而不是让它显示在显示器上，bash shell提供了操作符，可以将命令的输出重定向到另一个位置(比如文件)，重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。

#### 1.1.5.1. 输出重定向

> &emsp;&emsp;bash shell用">"(大于号)和">>"(双大于号)来完成将命令的输出重定向到一个文件中。

- **注意**
    > - ">"重定向操作符会创建一个新文件(通过默认的"umask"设置权限)，如果文件之前存在，会覆盖原先数据；
    > - ">>"将命令的输出追加到已有文件中；

#### 1.1.5.2. 输入重定向

> &emsp;&emsp;输入重定向将文件的内容重定向到命令，输入重定向符号是"<"(小于号)。

- **注意**
    > - 另一种输入重定向方法称为内联输入重定向(inline input redirection):
    >   - 这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据；
    >   - 内联输入重定向符号是"<<"(双小于号)；
    >   - 必须指定一个**文本标记**来划分输入数据的开始和结尾,任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致；
    >   - 在命令行上使用内联输入重定向时，shell会用"PS2"环境变量中定义的**次提示符**，次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串；
    
- **eg**
    ```
    $ wc << FLG
    > hello world
    > now
    > happy
    > FLG
            3       4       22
    $
    ```

### 1.1.6. 管道

> &emsp;&emsp;管道连接(piping)可以将一个命令的输出直接重定向到另一个命令(却别与输出重定向的到文件)。

- **注意**
    > - 符号由**两个**竖线构成，一个在另一个**上面**。然而管道符号的印刷体通常看起来更像是单个竖线"|"；
    > - 管道串起的两个命令**不是**依次执行，是同时运行，在第一个命令产生输出的同时，输出会被立即送给第二个命令，数据传输不会用到任何中间文件或缓冲区，第一个命令每有一个输出，基本上同时输入第二个命令；
    > - 可以在一条命令中使用任意多条管道,可以持续地将命令的输出通过管道传给其他命令来细化操作；
    > - 也可以搭配使用重定向和管道来将输出保存到文件中；
    ```
    $ ls -l | sort | more
    $
    $ ls -l | sort > log
    ```

### 1.1.7. 执行数学运算

> &emsp;&emsp;shell脚本处理操作数字的过程会比较麻烦，有两种途径来进行数学运算。

#### 1.1.7.1. expr命令

> &emsp;&emsp;"expr"命令允许在命令行处理数学表达式，但是特别笨拙，"expr"命令能够识别少数的数学和字符串操作符。

- **注意**
    > - 对于那些容易被shell错误解释的字符，在它们传入"expr"命令之前需要使用shell的转义字符(反斜线)将其标出来；
    > - 要将一个数学算式的结果赋给一个变量，需要使用命令替换来获取 expr 命令的输出`var3=$(expr $var1 / $var2)`；

#### 1.1.7.2. 使用方括号

- **注意**
    > - 在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号"$[ operation ]"将数学表达式围起来，适用于shell脚本；
    > - 在使用方括号来计算公式时，不用担心shell会误解乘号或其他符号；
    > - bash shell数学运算符只支持**整数运算**，z shell(zsh)提供了完整的浮点数算术操作；

#### 1.1.7.3. 浮点解决方案

- 克服bash中数学运算的整数限制的几种解决方案：
    - 使用内建的bash计算器(bc)
        - 通过bc命令访问bash计算器；
        - "quit"命令退出,"q"不可以；
        - 浮点运算是由内建变量"scale"控制(控制小数位，默认0)；
        - "bc -q"中的"-q"，命令行选项可以不显示bash计算器冗长的欢迎信息；
        - bash计算器还能支持变量，变量一旦被定义，你就可以在整个bash计算器会话中使用该变量了；
        - print 语句允许你打印变量和数字；
    - 在脚本中使用 bc
        - shell脚本中可以用命令替换运行"bc"命令，并将输出赋给一个变量，格式：`variable=$(echo "options; expression" | bc)`，"options"允许你设置变量(`var1=$(echo "scale=4; 3.44 / 5" | bc)`),如果不止一个变量，可用分号将其分开，"expression"参数定义了通过"bc"执行的数学表达式。
        - "bc"命令能识别输入重定向，允许你将一个文件重定向到"bc"命令来处理.在shell脚本中使用内联输入重定向
            ```
            variable=$(bc << EOF
            options
            statements
            expressions
            EOF
            )
            ```

### 1.1.8. 退出脚本

- **注意**
    > - shell中运行的每个命令都使用退出状态码告诉shell它已经运行完毕；
    > - 退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以**捕获**这个值并**在脚本中**使用；
    > - 变量"$?"保存上个已执行命令的退出状态码；
    > - 默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出；
    > - "exit"命令允许你在脚本结束时指定一个退出状态码，"exit"命令的参数可以是变量，但其值要在0~255范围；

## 1.2. 使用结构化命令

> &emsp;&emsp;程序要求对shell脚本中的命令施加一些逻辑流程控制,有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令(structured command)。

### 1.2.1. if-then和if-then-else

- 几种格式：

    ```
    if command
    then
        commands
    fi
    ```
    ```
    if command; then
        commands
    fi
    ```
    ```
    if command
    then
        commands
    else
        commands
    fi
    ```
    ```
    if command
    then
        commands
    elif
    then
        if command
        then
            commands
        fi
    elif
    then
        commands
    fi
    ```

- **注意**
> - bash shell的if语句会运行if后面的那个命令，如果该命令的退出状态码是0(该命令成功运行)，位于then部分的命令就会被执行；
> - then语句或else语句后可一次执行多条命令；
> - 可以使用嵌套的"if-then"语句；
> - 同一个级的"elif"语句过多的时候可以考虑使用"case"命令；

### 1.2.2. test命令

> &emsp;&emsp;"if-then"语句是**不能**测试命令退出状态码之外的条件。"test"命令提供了在"if-then"语句中测试不同条件的途径,如果"test"命令中列出的条件成立，"test"命令就会退出并返回退出状态码0，如果条件不成立，" test"命令就会退出并返回非零的退出状态码。

- **两种格式**
    ```
    if test condition
    then
        commands
    fi
    ```
    ```
    if [  condition ]
    then
        commands
    fi
    ```
    - 方括号定义了测试条件,第一个方括号之后和第二个方括号之前必须加上一个空格；
    - condition 是 test 命令要测试的一系列参数和值
    - 如果不写 test 命令的 condition 部分，它会以非零的退出状态码退出

- **test使用**
    - 数值比较；
    - 字符串比较；
    - 文件比较；

### 1.2.3. 复合条件

> &emsp;&emsp;"if-then"语句允许你使用布尔逻辑来组合测试。

- ` [ condition1 ] && [ condition2 ]`
- ` [ condition1 ] || [ condition2 ]`

### 1.2.4. "if-then"高级特性

- 用于数学表达式的**双括号**
- 用于高级字符串处理功能的**双方括号**

####  1.2.4.1. 双括号

- 格式：`(( expression ))`，"expression"可以是任意的数学赋值或比较表达式
- "test"命令只能在比较中使用简单的算术操作；
- 双括号命令在比较中使用高级数学表达式，双括号命令提供了更多的数学符号；
- 不需要将双括号中表达式里的大于号转义

#### 1.2.4.2. 双方括号

- 格式：`[[ expression ]]`
- 双方括号里的"expression"使用了"test"命令的标准字符串比较
- 双方括号提供了模式匹配(pattern matching)
- 不是所有的shell都支持双方括号

### 1.2.5. case命令

- **格式**
    ```
        case  variable in
        pattern1 |  pattern2 )  
                commands1 ;;
        pattern3 )  
                commands2 ;;
        *)   
                commands ;;
        esac
    ```
- "case"命令可以替代"elif"语句；
- "case"命令会采用列表格式来检查单个变量的多个值
- 竖线操作符在一行中分隔出多个模式匹配
- 星号会捕获所有与已知模式不匹配的值

## 1.3. 更多结构化命令

### 1.3.1. for命令

- **格式**
    ```
    for var in list
    do
        commands
    done
    ```

- "for"命令创建一个遍历一系列值的循环,每次迭代都使用其中一个值来执行已定义好的一组命令；
- 在"list"参数中需要提供迭代中要用到的一系列值
- "list"可以通过几种不同的方法指定列表中的值
- 在"do"和"done"语句之间命令可以是一条或多条标准的bash shell命令,在这些命令中，"$var"变量包含着这次迭代对应的当前列表项中的值

#### 1.3.1.1. 读取列表中的值

- **格式**
    ```
        for var in Aaaaaa S Ds Fa Gkjksdf Hhhh Jj
        do
            echo The next state is $var
        done
    ```
- 列表中将可能的值一一罗列；
- 每次“for”命令遍历值列表，它都会将列表中的下个值赋给变量
- 最后一次迭代后变量的值会在shell脚本的剩余部分一直保持有效,之后可以修改并使用；

#### 1.3.1.2. 读取列表中的复杂值

-  使用转义字符"\"(反斜线)来将单引号转义
- 使用双引号来定义用到单引号的值
-  for 循环假定每个值都是用空格分割的,在单独的数据值中有空格，就必须用双引号将这些值圈起来

#### 1.3.1.3. 从变量读取列表

- 将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表
- 向变量中存储的已有文本字符串尾部添加文本的一个常用方法  
- <font color=red>哪些情况下使用双引号？</font>
    ```
    #!/bin/sh
    # expole

    var="aaa bbb wejf lkfjj lksjk kjsdf sd"
    var=$var" lllkjkdj"

    for sta in $var
    do 
        echo "ccurent sta: $sta!"
    done
    ```

#### 1.3.1.4. 从命令读取值

- 列表中所需值可以是命令的输出，用**命令替换**来执行任何能产生输出的命令，然后在 for 命令中使用该命令的输出；
- 一行中的空格和回车换行都看作空格处理；

```
#!/bin/sh
# test

#list=$(cat state)

#for var in $list
for var in $(cat state)
do
        echo "var:$var"
done

结果：
# cat state 
A B C
D
E
F
# . ./test.sh 
var:A
var:B
var:C
var:D
var:E
var:F
# 
```

#### 1.3.1.5. 更改字段分隔符

- 环境变量IFS(内部字段分隔符)定义了shell用作字段分隔符的一系列字符；
- 默认IFS包括：空格、制表符、换行符
- <font color=red>为什么IFS=$'\n'要使用$符号</font>，"IFS='\n'"会将\和n作为换行符
```
#!/bin/sh
# test

file="state"

IFS=$'\n'

for var in $(cat file)
do
        echo "var:$var"
done

结果：
# . ./test.sh 
var:A B C
var:D
var:E
var:F
# 
```

- 保留旧值方便统一脚本中再次使用
```
IFS.OLD=$IFS
IFS=$'\n'
# ...
IFS=$IFS.OLD
#...
```
- 可以使用"IFS=:"来解析/etc/passwd文件；

#### 1.3.1.6. 用通配符读取目录

-  for 命令可以自动遍历目录中的文件，进行此操作时，必须在文件名或路径名中使用通配符，它会强制shell使用文件扩展匹配
- 文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程
- 在Linux中，目录名和文件名中包含空格当然是合法的，所以建议加双引号`if [ -d "$file" ]`
- 可以在 for 命令中列出多个目录通配符，将目录查找和列表合并进同一个 for 语句`for file in /home/rich/.b* /home/rich/badtest`

### 1.3.2. C语言风格的for命令

#### 1.3.2.1. C语言的for命令

- **格式**
    ```
    for (( variable assignment ; condition ; iteration process ))

    for (( a = 1; a < 10; a++ ))
    ```

- **注意**
    - 变量赋值可以有空格；
    - 条件中的变量不以美元符开头；
    - 迭代过程的算式未用 expr 命令格式。

#### 1.3.2.2. 使用多个变量

- **注意**
    - 尽管可以使用多个变量，但只能在"for"循环中定义一种条件;

### 1.3.3. while命令

#### 1.3.3.1. 基本格式

```
    while test command
    do
        other commands
    done
```

- **注意**
    - 每次迭代的一开始测试"test"命令,返回**非零**退出状态码时，"while"命令会**停止**执行那组命令；
    - "test command"可以使用任何普通的bash shell命令，或者用"test"命令进行条件测试；
    - 最常见的"test command"的用法是用方括号来检查循环命令中用到的shell变量的值；

#### 1.3.3.2. 使用多个测试命令

- **注意**
    - "while"命令允许你在"while"语句行定义多个测试命令,只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环；
    - 每个测试命令都出现在单独的一行上；
        ```
            $ cat test11
            #!/bin/bash
            # testing a multicommand while loop

            var1=10

            while echo $var1
                [ $var1 -ge 0 ]
            do
                echo "This is inside the loop"
                var1=$[ $var1 - 1 ]
            done
        ```

### 1.3.4. until命令

- **格式**
    ```
    until test commands
    do
        other commands
    done
    ```

- **注意**
    - "until"命令和"while"命令工作方式**相反**，"until"命令要求你指定一个通常返回非零退出状态码的测试命令；
    - 可以在"until"命令语句中放入多个测试命令，只有最后一个命令的退出状态码决定是否执行循环体； 

### 1.3.5. 循环嵌套

- 循环语句可以在循环内使用任意类型的命令，包括其他循环命令；

### 1.3.6. 循环处理文件数据

- **注意**
    - 使用嵌套循环；
    - 修改IFS环境变量(测试示例表面该环境变量的作用域在循环体内，退出后为原先值！)

- **示例**
    ```
        #!/bin/bash
        # changing the IFS value
       
        IFS.OLD=$IFS

        IFS=$'\n'       
        for entry in $(cat /etc/passwd)
        do
            echo "Values in $entry –"

            IFS=:            
            for value in $entry
            do
                echo " $value"
            done
        done
    ```

### 1.3.7. 控制循环

#### 1.3.7.1. break命令

- **注意**
    - 可以用"break"命令来退出任意类型的循环，包括"while"、"until"和"for"循环；
    - `break n`可以跳出多层循环，默认是1；

#### 1.3.7.2. continue命令

- **注意**
    - "continue"命令可以提前中止某次循环中的命令，但并不会完全终止整个循环；
    - 可以在"while"、"until"和"for"循环中使用；
    - `continue n`也可以使用；

### 1.3.8. 处理循环的输出

- 可以通过在"done"命令同行之后添加一个处理命令来实现重定向或管道；

    ```
        for file in /home/burgesskzg/*
        do
            if [ -d "$file" ]
            then
                echo "$file is a directory"
            elif
                echo "$file is a file"
            fi
        done > output.txt
    ```
    ```
        for state in "North Dakota" Connecticut Illinois Alabama Tennessee
        do
            echo "$state is the next place to go"
        done | sort
    ```

## 1.4. 处理用户输入

### 1.4.1. 命令行参数

- 命令行参数允许在运行脚本时向命令行添加数据以向脚本传递参数；
- 脚本会通过特殊的变量(位置参数\$0，\$1-\$9)来处理命令行参数，\$0是程序名，其他是参数；
- 每个参数都必须用空格分开；
- 命令行参数可以是数值，也可以是文本字符串；
- 要在参数值中包含空格，必须要用引号(单引号或双引号均可)，引号并非数据的一部分，它们只是表明数据的起止位置；
- 参数多余9个时，在脚本中需要在变量数字周围加上花括号引用(\${10})；

- "\$0"参数获取shell在命令行启动的脚本名；
- 以"."或"source"运行脚本，命令会和脚本名混在一起出现在"\$0"参数中！
- 以完整的脚本路径运行脚本时，"\$0"会包括整个路径和脚本！
- "basename"命令会返回不包含路径的脚本名；
    ```shell
        name=$(basename $0)
        echo
        echo The script name is: $name
        #
        $ bash /home/Christine/test5b.sh
        The script name is: test5b.sh
        $
        $ ./test5b.sh
        The script name is: test5b.sh
    ```

- 如果脚本中使用参数，但是执行是没有使用参数或缺少参数会导致出错；
- 在使用参数前一定要检查其中是否存在数据(`if [ -n "$1" ]`)；

### 1.4.2. 特殊参数变量

- bash shell中有些特殊变量，它们会记录命令行参数；
- "\$#"：含有脚本运行时携带的命令行参数的个数(不包括"\$0")；
- "\${\!\#}"：获取最后一个参数(不能在花括号内使用美元符，所用用"\!")；
- 当命令行没有参数时，"\$\#"的值为0，但"\${\!\#}"变量会返回命令行用到的脚本名；

- "\$\*"和"\$\@"：可以用来访问所有的参数，都能够在单个变量中存储所有的命令行参数；
- "\$\*"变量会将命令行上提供的所有参数当作一个单词保存，会将这些参数视为一个整体；
- "\$\@"变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词，可用for命令遍历；
- 使用"\$*"和"\$@"的使用要加双引号！

### 1.4.3. 移动变量

- "shift"命令会根据命令行参数的相对位置来移动命令行参数；
- 默认情况下会将每个参数变量向左移动一个位置("\$0"不会改变，但是"\$1"等参水会被一一删除)；
- 某个参数被移出无法再恢复！
- "shitf n"可以一次移除n个参数；

### 1.4.4. 处理选项

- 选项是跟在单破折线后面的单个字母；

- 处理简单选项 
    - 像处理命令行参数一样处理命令行选项；
    - "case"命令；
- 分离参数和选项(选项在前半部分，参数在后半部分) 
    - 在shell脚本中同时使用选项和参数的情况；
    - 用特殊字符将二者分开，该字符告诉脚本何时选项结束以及普通参数何时开始；
    - 特殊字符是"--"双破折线，shell会用双破折线来表明选项列表结束；
    - 也是通过"case"命令实现；
- 处理带值选项
    - 巧用"shift"命令；
    - 暂时无法处理**合并选项(-anlp)**的能力；

- "getopt"命令
    - 格式：`getopt optstring parameters`
        - "optstring"定义了命令行有效的选项字母，在"optstring"中列出要在脚本中用到的每个命令行选项字母;
        - "optstring"还定义了哪些选项字母需要参数值，需要参数值的选项字母后加一个冒号；
        - 自动将合并参数分开并加破折线；
        - 自动添加双破折线来分割额外参数；
        - 指定不在"optstring"中的选项，默认情况下会产生错误消息，命令后加"-q"选项可忽略；
        - "getopt"命令选项必须出现在"optstring"之前；
    - 能够识别命令行参数
    - 可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式；
- 可以在脚本中使用"getopt"来格式化脚本所携带的命令行选项或参数；
    - 需要借助"set"命令；
    - "set"命令能够处理"shell"中的各种变量；
    - "set"命令的选项之一是"--"(双破折线)，它会将脚本的命令行参数替换成"set"命令"--"之后的命令行值；
    - 实现方式`set -- $(getopt -q abc:d "$@")`；
- "getopt"命令不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符,引号当作字符；
    - `getopt ab -a -b "hello world"`会被解析未`-a -b 'hello world'`四个字段；

- "getopts"命令
    - 格式：`getopts optstring variable`
        - 选项字母列在"optstring"中;
        - 选项字母要求有个参数值，就加一个冒号；
        - 要去掉错误消息的话，可以在"optstring"之前加一个冒号；
        - "getopts"命令将当前参数保存在命令行中定义的"variable"中，**不带破折线**；
        - "getopts"命令会用到两个环境变量:
            - 如果选项需要跟一个参数值，"OPTARG"环境变量就会保存这个值；
            - "OPTIND"环境变量保存了参数列表中"getopts"正在处理的参数位置；
    - "getopts"命令内建于bash shell；
    -  "getopt"命令行上选项和参数处理后<font color=red>只生成一个输出</font>，而"getopts"命令能够和已有的shell参数变量配合默契;
    - "getopts"一次只处理命令行上检测到的一个参数，处理完所有的参数后，退出并返回一个大于0的退出状态码；
    - 可以在参数值中包含空格，用引号包裹含空格的参数，引号不被当作字符；
    - 可以将选项字母和参数值放在一起，不用加空格；
    - 将命令行上找到的所有未定义的选项统一输出成问号；
    - 知道何时停止处理选项，并将参数留给用户自己处理，利用`shift $[ $OPTIND - 1 ]`可移动获取参数；
    - 推荐使用方式：`while getopts :ab:c opt`；

### 1.4.5. 将选项标准化

> &emsp;&emsp;有些字母选项在Linux世界里已经拥有了某种程度的标准含义,建议在脚本中用相同含义实现选项。

|选项|描述|
|:---:|:---|
|-a|显示所有对象|
|-c|生成一个计数|
|-d|指定一个目录|
|-e|扩展一个对象|
|-f|指定读入数据的文件|
|-h|显示命令的帮助信息|
|-i|忽略文本大小写|
|-l|产生输出的长格式版本|
|-n|使用非交互模式(批处理)|
|-o|将所有输出重定向到的指定的输出文件|
|-q||
|-r|递归地处理目录和文件|
|-s|以安静模式运行|
|-v|生成详细输出|
|-x|排除某个对象|
|-y|对所有问题回答yes|

### 1.4.6. 获取用户输入

> &emsp;&emsp;命令行选项和参数是从脚本用户处获得输入的一种重要方式，而在脚本运行时想要和用户交互，可以使用"read"命令。

#### 1.4.6.1. 基本读取

- "read"命令从标准输入(键盘)或另一个文件描述符中接收输入；
- 收到输入后"read"命令会将数据放进一个变量；
    ```shell
        echo -n "Enter your name: "
        read name
        echo "Hello $name, welcome to my program. "
    ```
    - "echo"命令的"-n"选项在字符串结尾不输出换行；

- "read"命令包含"-p"选项，允许直接在"read"命令行指定提示符；
    ```shell
        read -p "Please enter your age: " age
        days=$[ $age * 365 ]
        echo "That makes you over $days days old! "
    ```

- "read"命令会将提示符后输入的所有数据分配给单个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量
    ```shell
        read -p "Enter your name: " first last
        echo "Checking data for $last, $first…"
        $
        $ ./test.sh
        Enter your name: Rich Blum
        Checking data for Blum, Rich...
    ```

- "read"命令行如果不指定变量，会将它收到的任何数据都放进特殊环境变量"REPLY"中；
    ```shell
        read -p "Enter your name: "
        echo
        echo Hello $REPLY, welcome to my program.
        #
        $
        $ ./test24.sh
        Enter your name: Christine
        Hello Christine, welcome to my program.
    ```

#### 1.4.6.2. 超时

- "-t"选项可以指定"read"命令等待输入的秒数；
- 当计时器过期还未输入数据，"read"命令会返回一个非零退出状态码(可以使用如"if-then"或"while"判断)；
    ```shell
        if read -t 5 -p "Please enter your name: " name
        then
            echo "Hello $name, welcome to my script"
        else
            echo
            echo "Sorry, too slow! "
        fi
    ```
    - "if"命令判断指令的退出码为0时为真！

- "-n"选项让"read"命令统计输入的字符数,当输入的字符达到预设的字符数时自动退出，将输入的数据赋给变量(无需按回车键)；
    ```shell
        read -n1 -p "Do you want to continue [Y/N]? " answer
        
        case $answer in
        Y | y)  echo
                echo "fine, continue on…";;

        N | n)  echo
                echo OK, goodbye
                exit;;
        esac
        echo "This is the end of the script"
    ```

#### 1.4.6.3. 隐藏方式读取

> &emsp;&emsp;敏感数据需要在输入回显时隐藏，如密码等。

- "-s"选项可以避免"read"命令中输入的数据出现在显示器上(实际上，数据会被显示，只是"read"命令会将文本颜色设成跟背景色一样)；
    ```shell
        read -s -p "Enter your password: " pass
        echo
        echo "Is your password really $pass? "
        $
        $ ./test.sh
        Enter your password:
        Is your password really T3st1ng?
        $
    ```
    - 输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。

#### 1.4.6.4. 从文件中读取

- "read"命令可以读取Linux系统上文件里保存的数据；
- 每次读取一行；
- 当文件中再没有内容时，"read"命令会退出并返回非零退出状态码；
    ```shell
        #!/bin/bash

        count=1
        cat test | while read line
        do
            echo "Line $count: $line"
            count=$[ $count + 1]
        done
        echo "Finished processing the file"
        $
        $ cat test
        The quick brown dog jumps over the lazy fox.
        This is a test, this is only a test.
        O Romeo, Romeo! Wherefore art thou Romeo?
        $
        $ ./test.sh
        Line 1: The quick brown dog jumps over the lazy fox.
        Line 2: This is a test, this is only a test.
        Line 3: O Romeo, Romeo! Wherefore art thou Romeo?
        Finished processing the file
        $
    ```
    - "read"命令不能直接读出文件中的内容，需要借助"cat"命令；

## 1.5. 呈现数据

> &emsp;&emsp;目前介绍的脚本都是通过将数据打印在屏幕上或将数据重定向到文件中来显示信息，接下来介绍如何将脚本的输出重定向到Linux系统的不同位置。

### 1.5.1. 理解输入和输出

> &emsp;&emsp;已知显示脚本输出方法："在显示器上显示输出"或者"将输出重定向到文件中"；
> &emsp;&emsp;这两种方法要么将数据输出全部显示，要么什么都不显示。有时需要将一部分数据在显示器上显示，另一部分数据保存到文件中，针对这种需求，需要了解Linux如何处理输入输出，如何用标准的Linux输入和输出系统来将脚本输出导向特定位置。

#### 1.5.1.1. 标准文件描述符

- Linux系统将每个对象当作文件处理，包括输入和输出进程；
- Linux用文件描述符来标识每个文件对象；
- 文件描述符是一个非负整数；
- 唯一标识会话中打开的文件；
- 每个进程一次最多可以有九个文件描述符；
- bash shell保留了前三个文件描述符(0-STDIN、1-STDOUT和2-STDERR)
- STDIN
    - 代表shell的标准输入;
    - 对终端界面来说，标准输入是键盘
    - shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符
    - 输入重定向符号会用重定向指定的文件来替换标准输入文件描述符
    - 当在命令行上只输入cat命令时，它会从STDIN接受输入
- STDOUT
    - STDOUT文件描述符代表shell的标准输出
    - 在终端界面上，标准输出就是终端显示器
    - 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符
    - 可以使用输出重定向">"或输出追加">>"来改变输出
    - shell对于错误消息的处理是跟普通输出分开的
- STDERR
    - shell通过特殊的 STDERR 文件描述符来处理错误消息
    - STDERR文件描述符代表shell的标准错误输出
    - shell或shell中运行的程序和脚本出错时生成的错误消息发送到这个描述符
    - 默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方，也会输出到显示器
    -  STDERR 并不会随着 STDOUT 的重定向而发生改变

#### 1.5.1.2. 重定向错误

- 只重定向错误
    - `ls -al badfile 2> test`
    - 2代表STDERR，将该文件描述符值放在重定向符号前
    - 该值必须紧紧地放在重定向符号前，不能有空格

- 重定向错误和数据
    - `ls -al test badtest 1>succOut 2>failOut`：将普通输出和错误分别定向到不同文件；
    - `ls -al test badtest &> Out`
        - 将普通输出和错误输出重定向到同一文件；
        - 为了避免错误信息散落在输出文件中，相较于标准输出，bashshell自动赋予了错误消息更高的优先级；<font color=red>需要按顺序输出怎么处理?</font>
    - <font color=red>怎么理解`./myproject > /dev/null 2>&1 &`？</font>

### 1.5.2. 在脚本中重定向输出

#### 1.5.2.1. 临时重定向

- `echo "this is an error message !" >&2`
    - 在脚本中单独将一行的输出定向到STDERR：
    - 在重定向到文件描述符时，必须在文件描述符数字之前加一个"&"
    - "... >&1"：将"..."重定向到1；
    - "... >&2"：将"..."重定向到2；

#### 1.5.2.1. 永久重定向

- `exec 1>SuccessOut`和`exec 2>FaileOut`
    - 在脚本中添加该语句，会启动一个新shell并将STDOUT文件描述符重定向到文件
    - 该指令不必放到脚本开始位置，可以在脚本执行过程中重定向；

### 1.5.3. 在脚本中重定向输入

- `exec 0< testfile`
    - "exec"命令将STDIN重定向到Linux系统上的文件中
    - 这个重定向只要在脚本需要输入时就会作用！

### 1.5.4. 创建自己的重定向

> &emsp;&emsp;shell中最多可以有9个打开的文件描述符，其他6个文件描述符均可用作输入或输出重定向。可以将这些文件描述符分配给文件，然后在脚本中使用。

#### 1.5.4.1. 创建输出文件描述符

```SHELL
    exec 3>TestOut

    echo "out to 3" >&3
```
- 用exec命令将文件描述符3重定向到另一个文件；
- 重定向到文件描述符3的echo语句的输出被输出到指定文件；
- 该方法可以将特定信息重定向到文件中(比如日志文件)
- `exec 3>>TestOut`：不创建新文件，使用追加方式；

#### 1.5.4.2. 重定向文件描述符

```SHELL
    exec 5>&1       #1
    exec 1>TestOut  #2
    
    #...    
    exec 1>&5       #3
```
- #1：将文件描述符5重定向到1，5和1都指向显示器；
- #2：将文件描述符1重定向到文件，5指向显示器，1指向TestOut；
- #3：将文件描述符1重定向到5，5和1都指向显示器；
- 这是一种在脚本中临时重定向输出，然后恢复默认输出设置的常用方法。

#### 1.5.4.3. 创建输入文件描述符

#### 1.5.4.4. 创建读写文件描述符


#### 1.5.4.5. 关闭文件描述符

### 1.5.5. 列出打开的文件描述符

### 1.5.6. 阻止命令输出

### 1.5.7. 创建临时文件

### 1.5.8 记录消息







# 疑问：
- shell内建命令有哪些？
- 运行命令的时候不加入路径就不会创建子shell？

```
file=/dir1/dir2/dir3/my.file.txt
可以用${ }分别替换得到不同的值：
${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt
${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt
${file#*.}：删掉第一个 .  及其左边的字符串：file.txt
${file##*.}：删掉最后一个 .  及其左边的字符串：txt
${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3
${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)
${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file
${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my
记忆的方法为：
# 是 去掉左边（键盘上#在 $ 的左边）
%是去掉右边（键盘上% 在$ 的右边）
单一符号是最小匹配；两个符号是最大匹配
${file:0:5}：提取最左边的 5 个字节：/dir1
${file:5:5}：提取第 5 个字节右边的连续5个字节：/dir2
也可以对变量值里的字符串作替换：
${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt

${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt
```

```
()和{}都是对一串的命令进行执行,但有所区别：
相同点：
()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开
不同点
()只是对一串命令重新开一个子shell进行执行,{}对一串命令在当前shell执行
()最后一个命令可以不用分号,{}最后一个命令要用分号
()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格
()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令
```

```
* 表示零个或多个任意字符
?表示零个或一个任意字符
[...]表示匹配中括号里面的字符
[!...]表示不匹配中括号里面的字符

shell脚本中read命令使用技巧(-r选项)

https://blog.csdn.net/wmjcode/article/details/80662501
```