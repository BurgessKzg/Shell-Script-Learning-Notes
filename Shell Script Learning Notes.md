> &emsp;&emsp;GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。
> &emsp;&emsp;在Linux系统上，通常有好几种Linux shell可用。不同的shell有不同的特性，有些更利于创建脚本，有些则更利于管理进程。

> &emsp;&emsp;将多个shell命令放入文件中作为程序执行,这些文件被称作shell脚本。

# 1. shell编程脚本基础

## 1.1. 构建基本脚本

### 1.1.1. 使用多个命令

> &emsp;&emsp;shell可以将多个命令串起来一次执行完成,如果要多个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开(不超过最大命令行字符数255)。  

 - **eg:**    
    ```Shell
    $ date ; who
    ```

### 1.1.2. 创建shell脚本文件

> 1. 使用文本编辑器创建一个文件；
> 2. 必须在文件的第一行指定要使用的shell，格式： "`#!/bin/bash`"，"bash"可以换为别的shell；
> 3. 指定shell后就可以在每一行输入命令，然后加一个回车符；

- **注意**
    > - shell脚本中**井号**(#)用作**注释行**，shell**不处理**注释行，**第一行**是个例外，"#"后面的惊叹号告诉shell用哪个shell来运行脚本; 
    > - shell脚本中注释可用"#"添加，可以出现在**任意行**；
    > - shell脚本中可以根据需要使用**分号**将多个命令放在一行上；
    > - shell会按命令在文件中出现的**顺序**进行处理；
    > - shell会通过"**PATH**环境变量"来查找命令；
    > - 执行脚本需要让shell能找到脚本位置，方法：
    >   - 将shell脚本文件所处的目录添加到"PATH"环境变量中；
    >   - 在提示符中用绝对或相对文件路径来引用shell脚本文件；
    > - 如果umask使得创建的文件没有执行权限，使用"chmod"添加执行权限；

### 1.1.3. 显示消息

> 在"echo"命令后加上一个字符串，该命令能回显这个文本字符串；  

- **注意**
    > - 默认情况**不需要**使用引号将要显示的文本字符串划定；
    > - 要显示的字符串包括"'"(单引号)时，需要将字符串用"""(双引号)划定；
    > - 要显示的字符串包括"""(双引号)时，需要将字符串用"'"(单引号)划定；
    > - 以上两条不必用"""(双引号)或"'"单引号将整个字符串划定起来；
    > - "echo"回显的数据默认会换行，可以加"-n"选项去掉换行； 

### 1.1.4. 使用变量

> &emsp;&emsp;变量允许你临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。

#### 1.1.4.1. 环境变量

> &emsp;&emsp;shell维护一组环境变量，用来记录特定系统信息。比如系统名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。可以用"**set**"命令来显示一份**完整的**当前环境变量列表。

> - 脚本中，可以在环境变量名称前加上"$"(美元符)来使用环境变量(不需要加"-n"选项)，这个时候可以将环境变量放到引号里；
> - 脚本在引号中出现"$"(美元符)，它会以为你在引用一个变量；
> - 要在引号中显示"$"(美元符)，需要在它前面添加"\\"(反斜线)；

#### 1.1.4.2. 用户变量

> &emsp;&emsp;shell脚本允许在脚本中定义和使用自己的变量(用户变量)，定义变量允许临时存储数据并在整个脚本中使用。

> - 用户变量可是字母、数字或下划线任意组成的文本字符串；
> - 用户变量长度不超过20个字符；
> - 用户变量区分大小写；
> - 使用等号赋值给用户变量，在变量、等号和值之间**不能**出现空格；
> - shell脚本会自动决定变量值的数据类型；
> - 在脚本的整个生命周期里，shell脚本中定义的变量会一直保持它们的值，**但**在shell脚本结束时会被**删除**；
> - 与系统变量类似，用户变量可通过"$"(美元符)引用，变量每次被引用时，都会输出当前赋给它的值；
> - 引用一个**变量值时需要**使用美元符，而引用变量来对其进行赋值时则**不需要**使用美元符，没有美元符，shell会将变量名解释成普通的文本字符串；
> - 通过"${variable}"形式引用的变量,变量名两侧额外的花括号通常用来帮助识别美元符后的变量名；

#### 1.1.4.3. 命令替换

> &emsp;&emsp;shell脚本中，可以从命令输出中提取信息，并将其赋给变量。

- 两种方法可以将命令输出赋给变量：
    > - "\`"(反引号)，用一对反引号把整个命令行命令围起来；
    ```Shell
    var=`date`
    ```
    > - "$()"格式    
    ```shell
    var=$(date)
    ```
- **注意**
    > - 反引号字符**不是**用于字符串的那种普通单引号字符；
    > - 命令替换会创建一个子shell来运行对应的命令,由该子shell所执行命令是无法使用脚本中所创建的变量；
    > - 在命令行提示符下使用路径"./"运行命令也会创建子shell；要是运行命令的时候不加入路径就不会创建子shell，如果使用内建的shell命令，并不会涉及子shell；

- **eg:**
    > - 在脚本中通过命令替换获得当前日期并用它来生成唯一文件名
    ```shell
    #!/bin/bash
    # copy the /usr/bin directory listing to a log file
    # 格式化后的"date"命令的输出
    today=$(date +%y%m%d)
    ls /usr/bin -al > log.$today
    ```

### 1.1.5. 重定向输入和输出

> &emsp;&emsp;有时想要保存某个命令的输出而不是让它显示在显示器上，bash shell提供了操作符，可以将命令的输出重定向到另一个位置(比如文件)，重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。

#### 1.1.5.1. 输出重定向

> &emsp;&emsp;bash shell用">"(大于号)和">>"(双大于号)来完成将命令的输出重定向到一个文件中。

- **注意**
    > - ">"重定向操作符会创建一个新文件(通过默认的"umask"设置权限)，如果文件之前存在，会覆盖原先数据；
    > - ">>"将命令的输出追加到已有文件中；

#### 1.1.5.2. 输入重定向

> &emsp;&emsp;输入重定向将文件的内容重定向到命令，输入重定向符号是"<"(小于号)。

- **注意**
    > - 另一种输入重定向方法称为内联输入重定向(inline input redirection):
    >   - 这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据；
    >   - 内联输入重定向符号是"<<"(双小于号)；
    >   - 必须指定一个**文本标记**来划分输入数据的开始和结尾,任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致；
    >   - 在命令行上使用内联输入重定向时，shell会用"PS2"环境变量中定义的**次提示符**，次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串；
    
- **eg**
    ```
    $ wc << FLG
    > hello world
    > now
    > happy
    > FLG
            3       4       22
    $
    ```

### 1.1.6. 管道

> &emsp;&emsp;管道连接(piping)可以将一个命令的输出直接重定向到另一个命令(却别与输出重定向的到文件)。

- **注意**
    > - 符号由**两个**竖线构成，一个在另一个**上面**。然而管道符号的印刷体通常看起来更像是单个竖线"|"；
    > - 管道串起的两个命令**不是**依次执行，是同时运行，在第一个命令产生输出的同时，输出会被立即送给第二个命令，数据传输不会用到任何中间文件或缓冲区，第一个命令每有一个输出，基本上同时输入第二个命令；
    > - 可以在一条命令中使用任意多条管道,可以持续地将命令的输出通过管道传给其他命令来细化操作；
    > - 也可以搭配使用重定向和管道来将输出保存到文件中；
    ```
    $ ls -l | sort | more
    $
    $ ls -l | sort > log
    ```

### 1.1.7. 执行数学运算

> &emsp;&emsp;shell脚本处理操作数字的过程会比较麻烦，有两种途径来进行数学运算。

#### 1.1.7.1. expr命令

> &emsp;&emsp;"expr"命令允许在命令行处理数学表达式，但是特别笨拙，"expr"命令能够识别少数的数学和字符串操作符。

- **注意**
    > - 对于那些容易被shell错误解释的字符，在它们传入"expr"命令之前需要使用shell的转义字符(反斜线)将其标出来；
    > - 要将一个数学算式的结果赋给一个变量，需要使用命令替换来获取 expr 命令的输出`var3=$(expr $var1 / $var2)`；

#### 1.1.7.2. 使用方括号

- **注意**
    > - 在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号"$[ operation ]"将数学表达式围起来，适用于shell脚本；
    > - 在使用方括号来计算公式时，不用担心shell会误解乘号或其他符号；
    > - bash shell数学运算符只支持**整数运算**，z shell(zsh)提供了完整的浮点数算术操作；

#### 1.1.7.3. 浮点解决方案

- 克服bash中数学运算的整数限制的几种解决方案：
    - 使用内建的bash计算器(bc)
        - 通过bc命令访问bash计算器；
        - "quit"命令退出,"q"不可以；
        - 浮点运算是由内建变量"scale"控制(控制小数位，默认0)；
        - "bc -q"中的"-q"，命令行选项可以不显示bash计算器冗长的欢迎信息；
        - bash计算器还能支持变量，变量一旦被定义，你就可以在整个bash计算器会话中使用该变量了；
        - print 语句允许你打印变量和数字；
    - 在脚本中使用 bc
        - shell脚本中可以用命令替换运行"bc"命令，并将输出赋给一个变量，格式：`variable=$(echo "options; expression" | bc)`，"options"允许你设置变量(`var1=$(echo "scale=4; 3.44 / 5" | bc)`),如果不止一个变量，可用分号将其分开，"expression"参数定义了通过"bc"执行的数学表达式。
        - "bc"命令能识别输入重定向，允许你将一个文件重定向到"bc"命令来处理.在shell脚本中使用内联输入重定向
            ```
            variable=$(bc << EOF
            options
            statements
            expressions
            EOF
            )
            ```

### 1.1.8. 退出脚本

- **注意**
    > - shell中运行的每个命令都使用退出状态码告诉shell它已经运行完毕；
    > - 退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以**捕获**这个值并**在脚本中**使用；
    > - 变量"$?"保存上个已执行命令的退出状态码；
    > - 默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出；
    > - "exit"命令允许你在脚本结束时指定一个退出状态码，"exit"命令的参数可以是变量，但其值要在0~255范围；

## 1.2. 使用结构化命令

> &emsp;&emsp;程序要求对shell脚本中的命令施加一些逻辑流程控制,有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令(structured command)。

### 1.2.1. if-then和if-then-else

- 几种格式：

    ```
    if command
    then
        commands
    fi
    ```
    ```
    if command; then
        commands
    fi
    ```
    ```
    if command
    then
        commands
    else
        commands
    fi
    ```
    ```
    if command
    then
        commands
    elif
    then
        if command
        then
            commands
        fi
    elif
    then
        commands
    fi
    ```

- **注意**
> - bash shell的if语句会运行if后面的那个命令，如果该命令的退出状态码是0(该命令成功运行)，位于then部分的命令就会被执行；
> - then语句或else语句后可一次执行多条命令；
> - 可以使用嵌套的"if-then"语句；
> - 同一个级的"elif"语句过多的时候可以考虑使用"case"命令；

### 1.2.2. test命令

> &emsp;&emsp;"if-then"语句是**不能**测试命令退出状态码之外的条件。"test"命令提供了在"if-then"语句中测试不同条件的途径,如果"test"命令中列出的条件成立，"test"命令就会退出并返回退出状态码0，如果条件不成立，" test"命令就会退出并返回非零的退出状态码。

- **两种格式**
    ```
    if test condition
    then
        commands
    fi
    ```
    ```
    if [  condition ]
    then
        commands
    fi
    ```
    - 方括号定义了测试条件,第一个方括号之后和第二个方括号之前必须加上一个空格；
    - condition 是 test 命令要测试的一系列参数和值
    - 如果不写 test 命令的 condition 部分，它会以非零的退出状态码退出

- **test使用**
    - 数值比较；
    - 字符串比较；
    - 文件比较；

### 1.2.3. 复合条件

> &emsp;&emsp;"if-then"语句允许你使用布尔逻辑来组合测试。

- ` [ condition1 ] && [ condition2 ]`
- ` [ condition1 ] || [ condition2 ]`

### 1.2.4. "if-then"高级特性

- 用于数学表达式的**双括号**
- 用于高级字符串处理功能的**双方括号**

####  1.2.4.1. 双括号

- 格式：`(( expression ))`，"expression"可以是任意的数学赋值或比较表达式
- "test"命令只能在比较中使用简单的算术操作；
- 双括号命令在比较中使用高级数学表达式，双括号命令提供了更多的数学符号；
- 不需要将双括号中表达式里的大于号转义

#### 1.2.4.2. 双方括号

- 格式：`[[ expression ]]`
- 双方括号里的"expression"使用了"test"命令的标准字符串比较
- 双方括号提供了模式匹配(pattern matching)
- 不是所有的shell都支持双方括号

### 1.2.5. case命令

- **格式**
    ```
        case  variable in
        pattern1 |  pattern2 )  
                commands1 ;;
        pattern3 )  
                commands2 ;;
        *)   
                commands ;;
        esac
    ```
- "case"命令可以替代"elif"语句；
- "case"命令会采用列表格式来检查单个变量的多个值
- 竖线操作符在一行中分隔出多个模式匹配
- 星号会捕获所有与已知模式不匹配的值

## 1.3. 更多结构化命令

### 1.3.1. for命令

- **格式**
    ```
    for var in list
    do
        commands
    done
    ```

- "for"命令创建一个遍历一系列值的循环,每次迭代都使用其中一个值来执行已定义好的一组命令；
- 在"list"参数中需要提供迭代中要用到的一系列值
- "list"可以通过几种不同的方法指定列表中的值
- 在"do"和"done"语句之间命令可以是一条或多条标准的bash shell命令,在这些命令中，"$var"变量包含着这次迭代对应的当前列表项中的值

#### 1.3.1.1. 读取列表中的值

- **格式**
    ```
        for var in Aaaaaa S Ds Fa Gkjksdf Hhhh Jj
        do
            echo The next state is $var
        done
    ```
- 列表中将可能的值一一罗列；
- 每次“for”命令遍历值列表，它都会将列表中的下个值赋给变量
- 最后一次迭代后变量的值会在shell脚本的剩余部分一直保持有效,之后可以修改并使用；

#### 1.3.1.2. 读取列表中的复杂值

-  使用转义字符"\"(反斜线)来将单引号转义
- 使用双引号来定义用到单引号的值
-  for 循环假定每个值都是用空格分割的,在单独的数据值中有空格，就必须用双引号将这些值圈起来

#### 1.3.1.3. 从变量读取列表

- 将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表
- 向变量中存储的已有文本字符串尾部添加文本的一个常用方法  
- <font color=red>哪些情况下使用双引号？</font>
    ```
    #!/bin/sh
    # expole

    var="aaa bbb wejf lkfjj lksjk kjsdf sd"
    var=$var" lllkjkdj"

    for sta in $var
    do 
        echo "ccurent sta: $sta!"
    done
    ```

#### 1.3.1.4. 从命令读取值

- 列表中所需值可以是命令的输出，用**命令替换**来执行任何能产生输出的命令，然后在 for 命令中使用该命令的输出；
- 一行中的空格和回车换行都看作空格处理；

```
#!/bin/sh
# test

#list=$(cat state)

#for var in $list
for var in $(cat state)
do
        echo "var:$var"
done

结果：
# cat state 
A B C
D
E
F
# . ./test.sh 
var:A
var:B
var:C
var:D
var:E
var:F
# 
```

#### 1.3.1.5. 更改字段分隔符

- 环境变量IFS(内部字段分隔符)定义了shell用作字段分隔符的一系列字符；
- 默认IFS包括：空格、制表符、换行符
- <font color=red>为什么IFS=$'\n'要使用$符号</font>，"IFS='\n'"会将\和n作为换行符
```
#!/bin/sh
# test

file="state"

IFS=$'\n'

for var in $(cat file)
do
        echo "var:$var"
done

结果：
# . ./test.sh 
var:A B C
var:D
var:E
var:F
# 
```

- 保留旧值方便统一脚本中再次使用
```
IFS.OLD=$IFS
IFS=$'\n'
# ...
IFS=$IFS.OLD
#...
```
- 可以使用"IFS=:"来解析/etc/passwd文件；

#### 1.3.1.6. 用通配符读取目录

-  for 命令可以自动遍历目录中的文件，进行此操作时，必须在文件名或路径名中使用通配符，它会强制shell使用文件扩展匹配
- 文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程
- 在Linux中，目录名和文件名中包含空格当然是合法的，所以建议加双引号`if [ -d "$file" ]`
- 可以在 for 命令中列出多个目录通配符，将目录查找和列表合并进同一个 for 语句`for file in /home/rich/.b* /home/rich/badtest`



















# 疑问：
- shell内建命令有哪些？
- 运行命令的时候不加入路径就不会创建子shell？

```
file=/dir1/dir2/dir3/my.file.txt
可以用${ }分别替换得到不同的值：
${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt
${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt
${file#*.}：删掉第一个 .  及其左边的字符串：file.txt
${file##*.}：删掉最后一个 .  及其左边的字符串：txt
${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3
${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)
${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file
${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my
记忆的方法为：
# 是 去掉左边（键盘上#在 $ 的左边）
%是去掉右边（键盘上% 在$ 的右边）
单一符号是最小匹配；两个符号是最大匹配
${file:0:5}：提取最左边的 5 个字节：/dir1
${file:5:5}：提取第 5 个字节右边的连续5个字节：/dir2
也可以对变量值里的字符串作替换：
${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt

${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt
```

```
()和{}都是对一串的命令进行执行,但有所区别：
相同点：
()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开
不同点
()只是对一串命令重新开一个子shell进行执行,{}对一串命令在当前shell执行
()最后一个命令可以不用分号,{}最后一个命令要用分号
()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格
()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令
```

```
* 表示零个或多个任意字符
?表示零个或一个任意字符
[...]表示匹配中括号里面的字符
[!...]表示不匹配中括号里面的字符

https://blog.csdn.net/wmjcode/article/details/80662501
```